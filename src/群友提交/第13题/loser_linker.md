``` c++
X f(){
    X x;
    return std::move(x);
}
```

有问题。使用 move 返回局部命名对象影响 nrvo 优化。

``` c++
X&& f(){
    X x;
    return std::move(x);
}
```

有问题。问题出在触发引用悬挂。返回临时量的引用，右值引用也是引用，不是只有左值引用才算引用，返回的右值引用谬构，程序行为未定义。

``` c++
struct Test {
    X x;
    X f() {
        return std::move(x);
    }
};
```

没问题。用来移出成员变量,因为成员变量不是默认可移动实体，需要转成右值引用来强制移动操作。不过，典型的移动构造函数“窃取”实参曾保有的资源（例如指向动态分配对象的指针，文件描述符，TCP socket，输入输出流，运行的线程，等等），而非复制它们，并使它的实参遗留在某个合法但不确定的状态。例如，从 std::string 或从 std::vector 移动可以导致实参被置为空。但是不应该依赖此类行为。
