
// 这个问题用名字查找来解释，如果不加this，首先在模板作用域内进行查找这个函数，如果没有，编译器认为是类外非成员函数。如果想调用父类模板的这个函数，需要加上作用域限定 X<T>::或者 this-> 。
// 为什么模板函数不能直接使用父类的方法，名字查找依赖于模板参数，我认为是模板参数的实际类型确定要根据实际实例化的类型最终确定，如果父类有特化并且没有这个函数，那么实例化后这个就应该报错。再往下有点理解不了了。
