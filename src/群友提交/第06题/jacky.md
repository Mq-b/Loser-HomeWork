`std::atomic<int> n = 6` 中，由于 `Literal[6]`（aka. int）和 `std::atomic<int>` 不是同一类型，所以会首先调用*用户定义的转换序列（user-defined conversion sequences）*（这里就是转换构造函数），然后进行直接初始化，结果类似 `std::atomic<int> n(std::atomic<int>(6))`。在 C++17 以下的版本中，编译器会首先检查移动构造函数（因为 `std::atomic<int>(6)` 是纯右值临时量/表达式），然而 `std::atomic<int>` 的移动构造函数已被删除，所以会回退到使用复制构造函数。然而复制构造函数也被删除，所以报错，编译停止；在 C++17 及以后，标准引入了强制性的复制消除，会直接用（纯右值）初始化器表达式自身以初始化，因此能够成功编译。
